package studio

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"gopkg.in/yaml.v3"
)

// ExportSchema handles GET /api/export/schema?format=sql|json|yaml|dbml|png|pdf
func (h *Handlers) ExportSchema(c *gin.Context) {
	format := c.DefaultQuery("format", "json")

	switch format {
	case "sql":
		content := ExportSchemaSQL(h.Schema)
		c.Header("Content-Disposition", "attachment; filename=schema.sql")
		c.Data(http.StatusOK, "text/sql; charset=utf-8", []byte(content))

	case "json":
		data, err := ExportSchemaJSON(h.Schema)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}
		c.Header("Content-Disposition", "attachment; filename=schema.json")
		c.Data(http.StatusOK, "application/json", data)

	case "yaml":
		data, err := ExportSchemaYAML(h.Schema)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}
		c.Header("Content-Disposition", "attachment; filename=schema.yaml")
		c.Data(http.StatusOK, "text/yaml; charset=utf-8", data)

	case "dbml":
		content := ExportSchemaDBML(h.Schema)
		c.Header("Content-Disposition", "attachment; filename=schema.dbml")
		c.Data(http.StatusOK, "text/plain; charset=utf-8", []byte(content))

	case "png":
		c.Header("Content-Disposition", "attachment; filename=erd.png")
		c.Header("Content-Type", "image/png")
		if err := RenderERDPNG(h.Schema, c.Writer); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		}

	case "pdf":
		c.Header("Content-Disposition", "attachment; filename=erd.pdf")
		c.Header("Content-Type", "application/pdf")
		if err := RenderERDPDF(h.Schema, c.Writer); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		}

	default:
		c.JSON(http.StatusBadRequest, gin.H{"error": "unsupported format: " + format})
	}
}

// ExportGoModels handles GET /api/export/models
func (h *Handlers) ExportGoModels(c *gin.Context) {
	code := GenerateGoModels(h.Schema)
	c.Header("Content-Disposition", "attachment; filename=models.go")
	c.Data(http.StatusOK, "text/x-go; charset=utf-8", []byte(code))
}

// ExportSchemaSQL generates CREATE TABLE DDL statements for the entire schema.
func ExportSchemaSQL(schema *SchemaInfo) string {
	var sb strings.Builder
	sb.WriteString("-- Generated by GORM Studio\n")
	sb.WriteString(fmt.Sprintf("-- Driver: %s\n\n", schema.Driver))

	for _, table := range schema.Tables {
		sb.WriteString(generateCreateTableSQL(table, schema.Driver))
		sb.WriteString("\n\n")
	}
	return sb.String()
}

// ExportSchemaJSON returns the SchemaInfo marshaled as indented JSON.
func ExportSchemaJSON(schema *SchemaInfo) ([]byte, error) {
	return json.MarshalIndent(schema, "", "  ")
}

// ExportSchemaYAML returns the SchemaInfo marshaled as YAML.
func ExportSchemaYAML(schema *SchemaInfo) ([]byte, error) {
	return yaml.Marshal(schema)
}

// ExportSchemaDBML generates DBML format for dbdiagram.io.
func ExportSchemaDBML(schema *SchemaInfo) string {
	var sb strings.Builder
	sb.WriteString("// Generated by GORM Studio\n\n")

	for _, table := range schema.Tables {
		sb.WriteString(fmt.Sprintf("Table %s {\n", table.Name))
		for _, col := range table.Columns {
			var attrs []string
			if col.IsPrimaryKey {
				attrs = append(attrs, "pk")
			}
			if !col.IsNullable && !col.IsPrimaryKey {
				attrs = append(attrs, "not null")
			}
			if col.Default != "" {
				attrs = append(attrs, fmt.Sprintf("default: '%s'", col.Default))
			}

			attrStr := ""
			if len(attrs) > 0 {
				attrStr = " [" + strings.Join(attrs, ", ") + "]"
			}
			sb.WriteString(fmt.Sprintf("  %s %s%s\n", col.Name, dbmlType(col.Type), attrStr))
		}
		sb.WriteString("}\n\n")
	}

	// Write relationships
	for _, table := range schema.Tables {
		for _, col := range table.Columns {
			if col.IsForeignKey && col.ForeignTable != "" {
				sb.WriteString(fmt.Sprintf("Ref: %s.%s > %s.%s\n", table.Name, col.Name, col.ForeignTable, col.ForeignKey))
			}
		}
	}

	return sb.String()
}

// generateCreateTableSQL generates a CREATE TABLE statement for a single table.
func generateCreateTableSQL(table TableInfo, driver string) string {
	q := func(name string) string { return quoteIdent(driver, name) }

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("CREATE TABLE %s (\n", q(table.Name)))

	for i, col := range table.Columns {
		sqlType := mapColTypeToSQL(col, driver)
		sb.WriteString(fmt.Sprintf("  %s %s", q(col.Name), sqlType))

		if col.IsPrimaryKey {
			sb.WriteString(" PRIMARY KEY")
		}
		if !col.IsNullable && !col.IsPrimaryKey {
			sb.WriteString(" NOT NULL")
		}
		if col.Default != "" {
			sb.WriteString(fmt.Sprintf(" DEFAULT %s", col.Default))
		}

		if i < len(table.Columns)-1 {
			sb.WriteString(",")
		}
		sb.WriteString("\n")
	}

	// Foreign key constraints
	var fks []string
	for _, col := range table.Columns {
		if col.IsForeignKey && col.ForeignTable != "" {
			fks = append(fks, fmt.Sprintf("  ,FOREIGN KEY (%s) REFERENCES %s(%s)",
				q(col.Name), q(col.ForeignTable), q(col.ForeignKey)))
		}
	}
	for _, fk := range fks {
		sb.WriteString(fk + "\n")
	}

	sb.WriteString(");")
	return sb.String()
}

// mapColTypeToSQL maps a column's type for the target SQL dialect.
func mapColTypeToSQL(col ColumnInfo, driver string) string {
	t := strings.ToUpper(col.Type)
	if col.Type != "" {
		return col.Type
	}

	// Fallback from GoType
	switch col.GoType {
	case "int64", "uint", "int":
		if driver == "postgres" {
			return "BIGINT"
		}
		return "INTEGER"
	case "string":
		return "TEXT"
	case "bool":
		return "BOOLEAN"
	case "float64":
		return "REAL"
	case "time.Time":
		if driver == "postgres" {
			return "TIMESTAMP"
		}
		return "DATETIME"
	default:
		_ = t
		return "TEXT"
	}
}

// dbmlType converts SQL types to DBML-friendly types.
func dbmlType(sqlType string) string {
	t := strings.ToLower(sqlType)
	// Strip size for cleaner DBML
	if idx := strings.Index(t, "("); idx >= 0 {
		base := t[:idx]
		return base + t[idx:]
	}
	return t
}
