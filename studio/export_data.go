package studio

import (
	"archive/zip"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
)

// ExportAllData handles GET /api/export/data?format=json|csv|sql
func (h *Handlers) ExportAllData(c *gin.Context) {
	format := c.DefaultQuery("format", "json")

	switch format {
	case "json":
		h.exportAllDataJSON(c)
	case "csv":
		h.exportAllDataCSV(c)
	case "sql":
		h.exportAllDataSQL(c)
	default:
		c.JSON(http.StatusBadRequest, gin.H{"error": "unsupported format: " + format + ". Use json, csv, or sql"})
	}
}

func (h *Handlers) exportAllDataJSON(c *gin.Context) {
	result := map[string]interface{}{
		"database":    h.Schema.Database,
		"driver":      h.Schema.Driver,
		"exported_at": time.Now().UTC().Format(time.RFC3339),
	}

	tablesData := make(map[string]interface{})
	for _, table := range h.Schema.Tables {
		var rows []map[string]interface{}
		if err := h.DB.Table(table.Name).Find(&rows).Error; err != nil {
			continue
		}
		colNames := make([]string, len(table.Columns))
		for i, col := range table.Columns {
			colNames[i] = col.Name
		}
		tablesData[table.Name] = map[string]interface{}{
			"columns":   colNames,
			"row_count": len(rows),
			"rows":      rows,
		}
	}
	result["tables"] = tablesData

	c.Header("Content-Disposition", "attachment; filename=database_export.json")
	c.Header("Content-Type", "application/json")

	encoder := json.NewEncoder(c.Writer)
	encoder.SetIndent("", "  ")
	encoder.Encode(result)
}

func (h *Handlers) exportAllDataCSV(c *gin.Context) {
	c.Header("Content-Type", "application/zip")
	c.Header("Content-Disposition", "attachment; filename=database_export.zip")

	zw := zip.NewWriter(c.Writer)
	defer zw.Close()

	for _, table := range h.Schema.Tables {
		var rows []map[string]interface{}
		if err := h.DB.Table(table.Name).Find(&rows).Error; err != nil {
			continue
		}

		w, err := zw.Create(table.Name + ".csv")
		if err != nil {
			continue
		}

		csvWriter := csv.NewWriter(w)

		// Header
		colNames := make([]string, len(table.Columns))
		for i, col := range table.Columns {
			colNames[i] = col.Name
		}
		csvWriter.Write(colNames)

		// Data rows
		for _, row := range rows {
			record := make([]string, len(table.Columns))
			for i, col := range table.Columns {
				val := row[col.Name]
				if val == nil {
					record[i] = ""
				} else {
					s := fmt.Sprintf("%v", val)
					// Sanitize formula injection
					if len(s) > 0 && (s[0] == '=' || s[0] == '+' || s[0] == '-' || s[0] == '@') {
						s = "'" + s
					}
					record[i] = s
				}
			}
			csvWriter.Write(record)
		}
		csvWriter.Flush()
	}
}

func (h *Handlers) exportAllDataSQL(c *gin.Context) {
	c.Header("Content-Disposition", "attachment; filename=database_export.sql")
	c.Header("Content-Type", "text/sql; charset=utf-8")

	var sb strings.Builder
	sb.WriteString("-- Database export generated by GORM Studio\n")
	sb.WriteString(fmt.Sprintf("-- Driver: %s\n", h.Schema.Driver))
	sb.WriteString(fmt.Sprintf("-- Exported at: %s\n\n", time.Now().UTC().Format(time.RFC3339)))

	driver := h.DB.Dialector.Name()

	for _, table := range h.Schema.Tables {
		var rows []map[string]interface{}
		if err := h.DB.Table(table.Name).Find(&rows).Error; err != nil {
			continue
		}

		if len(rows) == 0 {
			continue
		}

		sb.WriteString(fmt.Sprintf("-- Table: %s (%d rows)\n", table.Name, len(rows)))

		for _, row := range rows {
			colNames := make([]string, 0, len(table.Columns))
			values := make([]string, 0, len(table.Columns))

			for _, col := range table.Columns {
				val := row[col.Name]
				if val == nil {
					continue
				}
				colNames = append(colNames, quoteIdent(driver, col.Name))
				values = append(values, formatSQLValue(val))
			}

			if len(colNames) > 0 {
				sb.WriteString(fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s);\n",
					quoteIdent(driver, table.Name),
					strings.Join(colNames, ", "),
					strings.Join(values, ", ")))
			}
		}
		sb.WriteString("\n")
	}

	c.Writer.WriteString(sb.String())
}

// formatSQLValue formats a Go value as a SQL literal.
func formatSQLValue(val interface{}) string {
	if val == nil {
		return "NULL"
	}
	switch v := val.(type) {
	case float64:
		if v == float64(int64(v)) {
			return fmt.Sprintf("%d", int64(v))
		}
		return fmt.Sprintf("%g", v)
	case bool:
		if v {
			return "1"
		}
		return "0"
	case string:
		escaped := strings.ReplaceAll(v, "'", "''")
		return "'" + escaped + "'"
	default:
		escaped := strings.ReplaceAll(fmt.Sprintf("%v", v), "'", "''")
		return "'" + escaped + "'"
	}
}
